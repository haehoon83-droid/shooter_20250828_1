<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>NEON STRIKE</title>
<style>
  :root{
    --bg:#03040a;
    --grid:#0ff3;
    --hud:#9ef;
    --accent:#0ff;
    --danger:#ff3b;
    --warn:#ff0;
    --ok:#3f6;
  }
  html,body{margin:0;height:100%;background:radial-gradient(1200px 800px at 50% -200px,#081024 20%,#040712 60%,#02040a 100%) fixed; color:#cfe7ff; font-family:system-ui,Segoe UI,Apple SD Gothic Neo,Pretendard,sans-serif;}
  #wrap{max-width:520px;margin:0 auto;padding:8px;}
  .hud{display:flex;justify-content:space-between;align-items:center;color:var(--hud);gap:8px;margin:6px 2px 8px;}
  .hud .left, .hud .right{display:flex;gap:12px;align-items:center;font-weight:600}
  .tag{padding:2px 8px;border:1px solid #1a2438;border-radius:10px;background:#0a1020aa;box-shadow:0 0 12px #0ff2 inset; font-size:13px}
  .tag strong{color:#fff}
  #game{width:100%;height:auto;display:block;border:1px solid #101828;background:#000;box-shadow:0 0 24px #0ff2, inset 0 0 40px #002233;}
  .btnrow{display:flex;gap:8px;justify-content:flex-end;margin:8px 2px}
  button{background:#101828;color:#cfe7ff;border:1px solid #1f2b46;padding:6px 10px;border-radius:8px;cursor:pointer}
  button:hover{background:#0d2238}
  /* Touch controls */
  .touch{
    position:relative; margin-top:6px; height:140px; user-select:none; -webkit-user-select:none;
  }
  .padL,.padR,.padFire,.padDash{
    position:absolute; border-radius:50%; border:1px solid #0a2c44; background:#08122499; box-shadow:0 0 18px #0ff3 inset, 0 0 12px #0ff1; touch-action:none;
  }
  .padL{left:8px; bottom:8px; width:110px; height:110px;}
  .padR{left:128px; bottom:8px; width:110px; height:110px;}
  .padFire{right:62px; bottom:8px; width:90px; height:90px;}
  .padDash{right:8px; bottom:22px; width:56px; height:56px;}
  .padLabel{
    position:absolute; width:100%; text-align:center; top:50%; transform:translateY(-50%); color:#9ef; font-size:12px; pointer-events:none;
    text-shadow:0 0 8px #0ff;
  }
  .hint{font-size:12px;color:#89a8c6;text-align:right}
  .legend{font-size:12px;color:#8dd; margin:4px 2px}
</style>
</head>
<body>
  <div id="wrap">
    <div class="hud">
      <div class="left">
        <div class="tag">Score: <strong id="score">0</strong></div>
        <div class="tag">Best: <strong id="best">0</strong></div>
        <div class="tag">Combo: <strong id="combo">1.0x</strong></div>
      </div>
      <div class="right">
        <div class="tag">Lives: <strong id="lives">3</strong></div>
        <div class="tag">Shield: <strong id="shield">0</strong></div>
      </div>
    </div>

    <canvas id="game" width="480" height="720" tabindex="0" aria-label="NEON STRIKE canvas"></canvas>
    <div class="legend">← →/A D 이동 • Space 발사 • Shift/X 대시 • P 일시정지 • R 재시작</div>

    <div class="btnrow">
      <button id="pause">일시 정지</button>
      <button id="restart">다시 시작</button>
    </div>

    <div class="touch" id="touchLayer" aria-hidden="true">
      <div class="padL"><div class="padLabel">LEFT</div></div>
      <div class="padR"><div class="padLabel">RIGHT</div></div>
      <div class="padFire"><div class="padLabel">FIRE</div></div>
      <div class="padDash"><div class="padLabel">DASH</div></div>
    </div>

    <div class="hint">포커스가 안 잡히면 캔버스를 한 번 클릭하세요 • 모바일은 아래 패드 사용</div>
  </div>

<script>
(() => {
  // ---------- Audio (WebAudio beeps) ----------
  const AC = window.AudioContext || window.webkitAudioContext;
  const audio = new AC();
  let audioUnlocked = false;
  const unlock = () => { if(!audioUnlocked){ const o = audio.createOscillator(); o.frequency.value=1; o.connect(audio.destination); o.start(); o.stop(audio.currentTime+0.01); audioUnlocked=true; } };
  const beep = (freq=440, time=0.06, type='sine', gain=0.02) => {
    if(!audioUnlocked) return;
    const o = audio.createOscillator();
    const g = audio.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = gain;
    o.connect(g); g.connect(audio.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, audio.currentTime + time);
    o.stop(audio.currentTime + time + 0.01);
  };
  const sfx = {
    shoot: () => beep(880, 0.05, 'triangle', 0.03),
    explode: () => { beep(180, 0.08, 'sawtooth', 0.04); setTimeout(()=>beep(120,0.09,'square',0.03),40); },
    power: () => beep(1200, 0.08, 'square', 0.03),
    hit: () => beep(300, 0.05, 'sine', 0.02),
    dash: () => beep(600, 0.04, 'triangle', 0.03),
    boss: () => { beep(260,0.12,'sawtooth',0.05); setTimeout(()=>beep(520,0.1,'square',0.03),80);}
  };

  // ---------- Canvas / DPR ----------
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const DPR = Math.min(2, window.devicePixelRatio || 1);
  const baseW = 480, baseH = 720;
  const resize = () => {
    const w = baseW, h = baseH;
    cvs.width = Math.floor(w * DPR);
    cvs.height = Math.floor(h * DPR);
    cvs.style.width = w + 'px';
    cvs.style.height = h + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  };
  resize(); addEventListener('resize', resize);

  // ---------- Game State ----------
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const comboEl = document.getElementById('combo');
  const livesEl = document.getElementById('lives');
  const shieldEl = document.getElementById('shield');
  const restartBtn = document.getElementById('restart');
  const pauseBtn = document.getElementById('pause');

  let best = +localStorage.getItem('neonstrike_best') || 0;
  bestEl.textContent = best;

  const W = baseW, H = baseH;
  const rnd = (a,b)=>Math.random()*(b-a)+a;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  const player = { x: W/2, y: H-90, w: 28, h: 22, speed: 4, vx:0, cd:0, dashCd:0, inv:0, shield:0, alive:true,
                   spread:0, pierce:false, haste:0 };
  let bullets = [];
  let enemies = [];
  let powers = [];
  let particles = [];
  let boss = null;

  let keys = {};
  let leftHeld=false, rightHeld=false, fireHeld=false;

  let score = 0, lives = 3, paused=false, gameOver=false;
  let spawnTimer = 0;
  let time = 0;
  let combo = 1, comboTimer = 0, nextBossScore = 30;

  // ---------- Background Grid ----------
  function drawGrid(t){
    ctx.save();
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = 'rgba(0,255,255,0.15)';
    ctx.lineWidth = 1;
    ctx.shadowColor = '#0ff';
    ctx.shadowBlur = 8;

    const cell = 36;
    const offset = (t*50)%cell;
    // vertical
    ctx.beginPath();
    for(let x = -offset; x <= W; x += cell){
      ctx.moveTo(x,0); ctx.lineTo(x,H);
    }
    // horizontal
    for(let y = (offset*0.8); y <= H+cell; y += cell){
      ctx.moveTo(0,y); ctx.lineTo(W,y);
    }
    ctx.stroke();
    ctx.restore();
  }

  // ---------- Drawing ----------
  function drawShip(px,py,w,h,color='#0ff'){
    ctx.save();
    ctx.translate(px,py);
    ctx.shadowColor = color;
    ctx.shadowBlur = 16;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(0,-h/2);
    ctx.lineTo(w/2,h/2);
    ctx.lineTo(0,h/4);
    ctx.lineTo(-w/2,h/2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
  function drawEnemy(e){
    ctx.save();
    ctx.translate(e.x,e.y);
    ctx.shadowColor = e.color;
    ctx.shadowBlur = 14;
    ctx.strokeStyle = e.color;
    ctx.fillStyle = e.fill || 'transparent';
    ctx.lineWidth = 2;
    if(e.type==='drone'){
      ctx.beginPath();
      ctx.arc(0,0,e.r,0,Math.PI*2);
      ctx.stroke();
      ctx.fill();
    }else if(e.type==='zig'){
      ctx.beginPath();
      ctx.moveTo(-e.r,-e.r); ctx.lineTo(e.r,0); ctx.lineTo(-e.r,e.r); ctx.closePath();
      ctx.stroke(); ctx.fill();
    }else if(e.type==='seeker'){
      ctx.beginPath();
      ctx.rect(-e.r,-e.r,e.r*2,e.r*2);
      ctx.stroke(); ctx.fill();
    }else if(e.type==='boss'){
      ctx.beginPath();
      ctx.arc(0,0,e.r,0,Math.PI*2);
      ctx.stroke(); 
      ctx.beginPath();
      ctx.arc(0,0,e.r*0.6,0,Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();
  }
  function drawBullet(b){
    ctx.save();
    ctx.translate(b.x,b.y);
    ctx.shadowColor = b.color;
    ctx.shadowBlur = 10;
    ctx.strokeStyle = b.color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0,6); ctx.lineTo(0,-6);
    ctx.stroke();
    ctx.restore();
  }
  function drawPower(p){
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.shadowColor = p.color; ctx.shadowBlur = 12;
    ctx.strokeStyle = p.color; ctx.lineWidth = 2;
    ctx.beginPath();
    if(p.kind==='shield'){ ctx.arc(0,0,10,0,Math.PI*2); }
    if(p.kind==='spread'){ ctx.moveTo(-10,0); ctx.lineTo(10,0); ctx.moveTo(0,-10); ctx.lineTo(0,10); }
    if(p.kind==='pierce'){ ctx.rect(-8,-8,16,16); }
    if(p.kind==='haste'){ ctx.moveTo(-8,8); ctx.lineTo(0,-8); ctx.lineTo(8,8); }
    if(p.kind==='heal'){ ctx.moveTo(-9,0); ctx.lineTo(9,0); ctx.moveTo(0,-9); ctx.lineTo(0,9); }
    ctx.stroke();
    ctx.restore();
  }
  function spark(x,y,color='#0ff',n=12){
    for(let i=0;i<n;i++){
      particles.push({x,y,vx:rnd(-2,2),vy:rnd(-2,2),life:rnd(20,35),r:rnd(1,2),color});
    }
  }
  function drawParticles(){
    for(const p of particles){
      ctx.save();
      ctx.globalAlpha = Math.max(0, p.life/35);
      ctx.shadowColor = p.color; ctx.shadowBlur = 12;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  // ---------- Helpers ----------
  const rectHit = (a,b)=>!(a.x+a.w/2 < b.x-b.w/2 || b.x+b.w/2 < a.x-a.w/2 || a.y+a.h/2 < b.y-b.h/2 || b.y+b.h/2 < a.y-a.h/2);
  const circleHit = (ax,ay,ar,bx,by,br)=>((ax-bx)**2 + (ay-by)**2) <= (ar+br)**2;

  // ---------- Spawns ----------
  function addEnemy(){
    const diff = 1 + score*0.02 + time*0.0008;
    const roll = Math.random();
    if(roll < 0.5){
      enemies.push({type:'drone', x:rnd(30,W-30), y:-20, r:rnd(10,16), vx:rnd(-0.4,0.4), vy:rnd(1.2,1.9)*diff, hp:2, color:'#0ff', fill:'#011d2a'});
    }else if(roll < 0.8){
      enemies.push({type:'zig', x:rnd(40,W-40), y:-20, r:rnd(12,18), phase:rnd(0,Math.PI), vy:rnd(1.6,2.2)*diff, hp:3, color:'#8af', fill:'#0a1530'});
    }else{
      enemies.push({type:'seeker', x:rnd(30,W-30), y:-20, r:rnd(10,14), vy:rnd(1.0,1.6)*diff, hp:2, color:'#f6f', fill:'#1b0825'});
    }
  }
  function spawnBoss(){
    boss = {type:'boss', x:W/2, y:120, r:60, vx:1.5, vy:0, hp:80 + Math.floor(score*0.8), color:'#ff5', phase:0, fire:0};
    enemies.push(boss);
    sfx.boss();
  }

  // ---------- Powers ----------
  function dropPower(x,y){
    const kinds = ['shield','spread','pierce','haste','heal'];
    const kind = kinds[Math.floor(rnd(0,kinds.length))];
    const colors = {shield:'#3ff', spread:'#6ff', pierce:'#f6f', haste:'#0f8', heal:'#6f6'};
    powers.push({x,y,vy:1.2,kind,color:colors[kind],life:600});
  }
  function applyPower(kind){
    if(kind==='shield'){ player.shield = Math.min(3, player.shield+1); }
    if(kind==='spread'){ player.spread = Math.min(2, player.spread+1); }
    if(kind==='pierce'){ player.pierce = true; setTimeout(()=>player.pierce=false, 15000); }
    if(kind==='haste'){ player.haste += 600; }
    if(kind==='heal'){ lives = Math.min(5, lives+1); }
    sfx.power();
  }

  // ---------- Input ----------
  addEventListener('keydown', e=>{
    if(!audioUnlocked){ unlock(); }
    keys[e.key.toLowerCase()] = true;
    if([' ','arrowleft','arrowright'].includes(e.key.toLowerCase())) e.preventDefault();
    if(e.key==='p' || e.key==='P'){ paused=!paused; }
    if(e.key==='r' || e.key==='R'){ restart(); }
  });
  addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });
  const moveInput = ()=>{ leftHeld = !!(keys['arrowleft']||keys['a']); rightHeld = !!(keys['arrowright']||keys['d']); fireHeld = !!(keys[' ']||keys['space']); };

  // Touch controls
  const touchLayer = document.getElementById('touchLayer');
  const q = sel=>touchLayer.querySelector(sel);
  const padL = q('.padL'), padR = q('.padR'), padF = q('.padFire'), padD = q('.padDash');
  function bindHold(el, cbDown, cbUp){
    const active = new Set();
    const onDown = e=>{ e.preventDefault(); [...(e.touches||[e])].forEach(t=>active.add(t.identifier||'m')); cbDown();};
    const onUp = e=>{ e.preventDefault(); active.clear(); cbUp(); };
    el.addEventListener('pointerdown', onDown); el.addEventListener('pointerup', onUp); el.addEventListener('pointerleave', onUp);
    el.addEventListener('touchstart', onDown, {passive:false}); el.addEventListener('touchend', onUp); el.addEventListener('touchcancel', onUp);
  }
  bindHold(padL, ()=>{ leftHeld=true; }, ()=>{ leftHeld=false; });
  bindHold(padR, ()=>{ rightHeld=true; }, ()=>{ rightHeld=false; });
  bindHold(padF, ()=>{ fireHeld=true; }, ()=>{ fireHeld=false; });
  bindHold(padD, ()=>{ dash(); }, ()=>{});

  // Buttons
  restartBtn.onclick = ()=>restart();
  pauseBtn.onclick = ()=>{ paused=!paused; cvs.focus(); };

  // ---------- Player Actions ----------
  function shoot(){
    if(player.cd>0) return;
    const base = { y: player.y - player.h/2 - 6, vy: -8, color:'#0ff', dmg:1, pierce: player.pierce ? 2 : 0 };
    const spread = player.spread;
    const arr = [];
    if(spread===0){
      arr.push({ x: player.x, ...base });
    }else if(spread===1){
      arr.push({ x: player.x-8, ...base, vx:-1 });
      arr.push({ x: player.x+8, ...base, vx: 1 });
    }else{
      arr.push({ x: player.x, ...base });
      arr.push({ x: player.x-10, ...base, vx:-1.2 });
      arr.push({ x: player.x+10, ...base, vx: 1.2 });
    }
    arr.forEach(b=>bullets.push({ ...b, w:4, h:12 }));
    player.cd = player.haste>0 ? 6 : 10;
    sfx.shoot();
  }
  function dash(){
    if(player.dashCd>0) return;
    player.inv = 30;
    player.dashCd = 60;
    sfx.dash();
    spark(player.x, player.y, '#0ff', 20);
  }
  function hitPlayer(){
    if(player.inv>0) return;
    if(player.shield>0){
      player.shield--; player.inv = 40; sfx.hit(); return;
    }
    lives--; player.inv = 50; sfx.hit();
    if(lives<=0){ player.alive=false; gameOver=true; }
  }

  // ---------- Loop ----------
  function restart(){
    score=0; lives=3; combo=1; comboTimer=0; nextBossScore=30;
    bullets.length=0; enemies.length=0; powers.length=0; particles.length=0;
    boss=null; paused=false; gameOver=false; time=0;
    Object.assign(player, { x:W/2, y:H-90, vx:0, cd:0, dashCd:0, inv:0, shield:0, alive:true, spread:0, pierce:false, haste:0 });
    cvs.focus();
  }

  function update(){
    moveInput();
    if(paused || gameOver) return;

    time++;

    // background
    drawGrid(time/60);

    // player move
    player.vx = (rightHeld?1:0) - (leftHeld?1:0);
    let spd = player.speed + (player.haste>0?1.8:0);
    player.x += player.vx * spd;
    player.x = clamp(player.x, 20, W-20);
    if(fireHeld) shoot();
    if(player.cd>0) player.cd--;
    if(player.dashCd>0) player.dashCd--;
    if(player.inv>0) player.inv--;
    if(player.haste>0) player.haste--;

    // spawn enemies
    if(spawnTimer--<=0){
      addEnemy();
      const base = 30;
      const accel = Math.max(10, base - Math.floor(score/5));
      spawnTimer = accel;
    }

    // boss spawn
    if(score >= nextBossScore && !boss){
      spawnBoss();
      nextBossScore += 45;
    }

    // bullets
    for(const b of bullets){
      b.y += b.vy; b.x += (b.vx||0);
    }
    bullets = bullets.filter(b=>b.y>-20);

    // enemies movement
    for(const e of enemies){
      if(e.type==='drone'){ e.x += e.vx; e.y += e.vy; if(e.x<20||e.x>W-20) e.vx*=-1; }
      if(e.type==='zig'){ e.phase += 0.08; e.x += Math.sin(e.phase)*2.4; e.y += e.vy; }
      if(e.type==='seeker'){ const dir = Math.sign(player.x - e.x); e.x += dir*1.2; e.y += e.vy; }
      if(e.type==='boss'){
        e.phase += 0.02; e.x += Math.sin(e.phase)*e.vx;
        if(e.fire--<=0){
          // radial shots
          const n = 8 + Math.floor(Math.random()*4);
          for(let i=0;i<n;i++){
            const ang = (Math.PI*2*i)/n;
            enemies.push({type:'drone', x:e.x+Math.cos(ang)*e.r*0.7, y:e.y+Math.sin(ang)*e.r*0.7, r:8, vx:Math.cos(ang)*0.8, vy:Math.sin(ang)*0.8+1.2, hp:1, color:'#ff8', fill:'#2a2400'});
          }
          e.fire = 120;
        }
      }
    }
    enemies = enemies.filter(e=> e.y < H+60 && (e.hp||1) > 0);

    // powers movement
    for(const p of powers){ p.y += p.vy; p.life--; }
    powers = powers.filter(p=> p.y < H+40 && p.life>0);

    // particles
    for(const p of particles){ p.x+=p.vx; p.y+=p.vy; p.life--; }
    particles = particles.filter(p=>p.life>0);

    // collisions bullets vs enemies
    for(const e of enemies){
      for(const b of bullets){
        if(e.type==='boss'){
          if(circleHit(e.x,e.y,e.r, b.x,b.y,6)){
            e.hp -= b.dmg;
            if(b.pierce>0){ b.pierce--; } else { b.y = -999; }
            spark(b.x,b.y,'#ff8',3);
            if(e.hp<=0){ score += Math.floor(20*combo); e.y = H+999; boss=null; spark(e.x,e.y,'#ff8',40); if(Math.random()<0.9) dropPower(e.x,e.y); }
          }
        }else{
          const rectA = {x:b.x, y:b.y, w:6, h:12};
          const rectB = {x:e.x, y:e.y, w:e.r*2, h:e.r*2};
          if(rectHit(rectA, rectB)){
            e.hp -= b.dmg;
            if(b.pierce>0){ b.pierce--; } else { b.y = -999; }
            score += Math.floor(1*combo);
            combo = Math.min(6, (combo + 0.05));
            comboTimer = 180;
            spark(e.x,e.y,e.color,6);
            if(e.hp<=0){
              e.y = H+999;
              if(Math.random()<0.18) dropPower(e.x,e.y);
              sfx.explode();
            }
          }
        }
      }
    }

    // combo decay
    if(comboTimer>0){ comboTimer--; } else { combo = Math.max(1, combo - 0.02); }

    // enemies vs player
    const pr = Math.max(player.w, player.h)/2;
    for(const e of enemies){
      let hit=false;
      if(e.type==='boss'){ hit = circleHit(player.x, player.y, pr, e.x, e.y, e.r-6); }
      else hit = circleHit(player.x, player.y, pr, e.x, e.y, e.r);
      if(hit){ hitPlayer(); }
    }

    // powers pickup
    for(const p of powers){
      if(circleHit(player.x,player.y,18, p.x,p.y,10)){
        applyPower(p.kind);
        p.life = -1;
      }
    }

    // draw player
    if(player.alive){
      if(player.inv>0 && Math.floor(player.inv/4)%2===0){
        // flicker
      }else{
        drawShip(player.x, player.y, player.w, player.h, '#0ff');
        if(player.shield>0){
          ctx.save();
          ctx.shadowColor='#3ff'; ctx.shadowBlur=12;
          ctx.strokeStyle='#3ff88'; ctx.lineWidth=2;
          ctx.beginPath(); ctx.arc(player.x,player.y,22,0,Math.PI*2); ctx.stroke();
          ctx.restore();
        }
      }
    }

    // draw bullets
    for(const b of bullets) drawBullet(b);
    // draw enemies
    for(const e of enemies) drawEnemy(e);
    // draw powers
    for(const p of powers) drawPower(p);
    // draw particles
    drawParticles();

    // HUD sync
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    comboEl.textContent = (Math.round(combo*10)/10).toFixed(1)+'x';
    shieldEl.textContent = player.shield;

    // Game Over
    if(gameOver){
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0,0,W,H);
      ctx.textAlign='center';
      ctx.shadowColor='#0ff'; ctx.shadowBlur=18;
      ctx.fillStyle='#cfe7ff';
      ctx.font='bold 32px system-ui';
      ctx.fillText('GAME OVER', W/2, H/2 - 10);
      ctx.font='16px system-ui';
      ctx.fillText(`Score ${score}  •  Best ${Math.max(best, score)}`, W/2, H/2 + 20);
      ctx.restore();
      best = Math.max(best, score);
      localStorage.setItem('neonstrike_best', best);
    }
  }

  function render(){
    if(!paused){
      update();
    }else{
      // paused overlay
      drawGrid(time/60);
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,W,H);
      ctx.textAlign='center'; ctx.fillStyle='#9ef';
      ctx.shadowColor='#0ff'; ctx.shadowBlur=12;
      ctx.font='bold 28px system-ui'; ctx.fillText('PAUSED', W/2, H/2);
      ctx.restore();
    }
    requestAnimationFrame(render);
  }
  render();

  // focus/unlock audio on first interaction
  ['pointerdown','touchstart','keydown'].forEach(ev=>{
    addEventListener(ev, ()=>{ unlock(); }, {once:true, passive:true});
  });

  // focus canvas initially
  setTimeout(()=>cvs.focus(), 300);
})();
</script>
</body>
</html>
